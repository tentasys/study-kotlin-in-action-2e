# 18장. 오류 처리와 테스트

# 18.1 코루틴 내부에서 던져진 오류 처리

```kotlin
fun main(): Unit = runBlocking { 
		try { 
				launch { 
						throw UnsupportedOperationException("Ouch!")
				}
		} catch (u: UnsupportedOperationException) {
				println("Handeled $u")
		}
}
```

- 위 코드에서 catch 블록은 실행되지 않음
- launch나 async와 같은 코루틴 빌더 함수를 통해 생성한 코루틴 → 여기서 생긴 에러는 코루틴 빌더를 감싼 try/catch에 잡히지 않음
- 코루틴 빌더 람다 블록 안에 try-catch를 넣으면 예외의 올바른 처리 가능
- async로 생성된 코루틴이 예외를 던진다면 await를 호출할 때 예외가 다시 발생
- async는 예외를 부모 코루틴에 전파한다

자식 코루틴과 부모 코루틴간의 예외 전파

- 자식 코루틴은 잡히지 않은 예외를 항상 부모 코루틴에 전파한다.
- 부모 코루틴이 자식 코루틴의 예외를 처리해야 할 책임을 가진다.

# 18.2 코틀린 코루틴에서의 오류 전파

자식에게 작업을 나누는 방식에 따라 자식의 오류를 처리하는 방법이 달라짐

1. 자식이 실패하면 모든 자식을 취소
2. 자식이 실패해도 전체 실패로 이어지지 않음

## 18.2.1 자식이 실패하면 모든 자식을 취소하는 코루틴

- 코루틴이 SupervisorJob 없이 생성된 경우, 자식 코루틴에서 발생한 잡히지 않는 예외는 부모 코루틴을 예외로 완료시킴
- 실패한 자식 코루틴은 자신의 실패를 부모에게 전파
- 전파된 실패를 받으면 부모가 하는 일
    - 다른 모든 자식 취소
    - 같은 예외를 발생시키며 자신의 실행 완료
    - 자신의 상위 계층으로 예외 전파
- 동시성 계산을 함께 수행하고 공통의 결과를 반환하는 코루틴 그룹에게 유용

## 18.2.2 구조적 동시성은 코루틴 스코프를 넘는 예외에만 영향을 미친다

- 예외를 상위로 전파하는 동작 → 코루틴 스코프를 넘는 처리되지 않는 예외에만 영향을 미침
- 처음부터 스코프를 넘지 않는 예외를 던지는 것이 중요
- CancellationException과 하위 타입 주의
    - 취소는 코루틴 생명주기의 자연스러운 부분
    - 이 예외를 실수로 잡아서는 안 됨

## 18.2.3 슈퍼바이저는 부모와 형제가 취소되지 않게 한다

- 슈퍼바이저는 자식이 실패하더라도 생존
    - 일부 자식이 실패를 보고하더라도 실패하지 않음
- 다른 자식 코루틴을 취소하지 않으며, 예외를 구조적 동시성 계층 상위로 전파하지 않음
- 코루틴 계층의 최상위 코루틴으로 사용됨
- supervisorScope
    - 자식 코루틴 중 하나가 실패해도 형제 코루틴이 종료되지 않고 처리되지 않은 예외는 전파되지 않음
    - 부모 코루틴과 형제 코루틴은 계속 작동

# 18.3 CoroutineExceptionHandler: 예외 처리를 위한 마지막 수단

- 예외가 슈퍼바이저에 도달하거나 부모가 없는 루트 코루틴에 도달하면 예외는 더 이상 전파되지 않음
- CoroutineExceptionHandler
    - 마지막 시점에서 처리되지 않은 예외가 처리되는 핸들러
    - 코루틴 콘텍스트의 일부
    - 콘텍스트에 예외 핸들러가 없다면 처리되지 않은 예외는 시스템 전역 예외 핸들러로 이동
    - jvm의 경우 핸들러가 예외 스택 트레이스를 오류 콘솔에 출력
    - 코루틴 콘텍스트에 제공하면 처리되지 않은 예외를 처리하는 동작 커스텀 가능

핸들러 정의

```kotlin
val exceptionHandler = CoroutineExceptionHandler { context, exception -> 
		println("ERROR] $exception") 
}
```

- 코루틴 콘텍스트와 처리되지 않은 예외를 람다의 파라미터로 받음
- 스코프를 슈퍼바이저로 만들고 사용자 정의 예외 핸들러를 코루틴 콘텍스트의 요소로 지정해 사용

커스텀 코루틴 예외 핸들러 처리 방식

- 슈퍼바이저의 직접적인 자식들이 콘텍스트의 커스텀 코루틴 예외 핸들러에 예외를 전달
- 디폴트 핸들러에게 예외를 전달
- 코루틴 예외 핸들러는 코루틴 계층에서 최상위 코루틴이 launch 빌더로 시작된 경우에만 호출됨
- 자식 코루틴은 처리되지 않은 예외의 처리를 부모에게 위임한다
    - 중간에 설정된 콘텍스트의 예외 핸들러는 처리되지 않음에 주의할 것!
    - 예외가 여전히 부모 코루틴에게 전파될 수 있기 때문
    - 루트 코루틴이 아닌 경우 예외가 계속해서 코루틴 계층을 따라 전파됨

## 18.3.1 CoroutineExceptionHandler를 launch와 async에 적용할 때의 차이점

- 예외 핸들러는 최상위 코루틴이 launch로 생성된 경우에만 호출됨
- 최상위 코루틴이 async로 생성된 경우에는 CoroutineExceptionHandler가 호출되지 않음
    - 예외를 처리하는 책임은 await()를 호출하는 Deferred의 소비자에게 있음
- 소비자는 await 호출을 try-catch 블록으로 감싸는 방식으로 예외 처리 필요
    - try-catch가 코루틴 취소에 영향을 끼치지 않음

# 18.4 플로우에서 예외 처리

- 플로우 예외 → collect에서 예외가 던져짐
    - collect 호출을 try-catch로 감싸면 예상대로 동작함
    - 중간 연산자 적용 여부와는 상관 없음

## 18.4.1 catch 연산자로 업스트림 예외 처리

- catch
    - 플로우에서 발생한 예외를 처리할 수 있는 중간 연산자
    - 람다 안에서 플로우에 발생한 예외에 접근 가능
    - 예외는 람다의 파라미터로 전달
    - 취소 예외를 자동으로 인식 → 취소가 발생한 경우에는 catch 블록이 호출되지 않음
    - 스스로 값을 방출 가능 → 예외를 오류 값으로 변환해 다운스트림 플로우에서 소비하도록 할 수 있음
    - 오직 업스트림에 대해서만 작동함
- 예외를 catch 블록에서 다시 던져서 다운스트림에 있는 다른 catch 연산자에서 처리하게 하는 것도 올바른 코드

## 18.4.2 술어가 참일 때 플로우의 수집 재시도: retry 연산자

retry

- 업스트림의 예외를 잡음
- 예외를 처리하고 Boolean 값을 반환하는 람다 사용 가능
- 람다가 true를 반환하면 재시도가 시작
- 재시도 동안 업스트림의 플로우가 처음부터 다시 수집되면서 모든 중간 연산이 다시 실행됨
    - 작업의 멱등성이 보장되어야 함

# 18.5 코루틴과 플로우 테스트

테스트 메서드에서의 코루틴 → runTest 사용

- runBlocking의 경우 테스트가 실시간으로 실행됨
- 코드에 delay가 지정된 경우, 결과가 계산되기 전에 시간 지연이 전부 실행됨

## 18.5.1 코루틴을 사용하는 테스트를 빠르게 만들기: 가상 시간과 테스트 디스패처

가상 시간

- 지연이 자동으로 빠르게 실행됨
- runTest는 속도를 높이기 위해 특별한 테스트 디스패처와 스케줄러를 사용함
- runTest의 디스패처는 단일 스레드
    - 모든 자식 코루틴은 동시에 실행되며, 테스트 코드와 병렬로 실행되지 않는다
- 단일 스레드 디스패처 공유 → 다른 코루틴이 코드를 실행하려면 코드 일시 중단 지점 제공 필요
- 테스트 디스패처가 아닌 일반 디스패처에서 시작된 코루틴은 항상 지연을 전부 기다려야 함

TestScope

- runTest빌더 함수의 블록 안에서 사용
- TestCoroutineScheduler 기능을 사용할 수 있게 해줌
- 스케줄러의 핵심 함수
    - runCurrent: 현재 실행하게 예약된 모든 코루틴을 실행
    - advancedUntileIdle: 예약된 모든 코루틴을 실행

## 18.5.2 터빈으로 플로우 테스트

플로우 테스트 작성에 도움을 주는 라이브러리

핵심 기능

- test
    - 플로우의 확장 함수
    - 새 코루틴을 실행하며 내부적으로 플로우를 수집
    - 플로우에 대한 불변 조건을 지정하고 검증
    - 플로우가 방출한 모든 원소가 테스트에 의해 적절히 소비되도록 보장
- 시스템 일부를 대체할 수 있는 독립적인 터빈 객체를 만드는 기능 제공